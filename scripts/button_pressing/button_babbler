#!/usr/bin/env python
""" This script controls baxter by randomly choosing position for the left-limb end effector and using the Inverse Kinematic service (hence IK) to reach this point.

The script also controls what is recorded, so that a snapshot of the world is recorded after every 3D position of the end-effector is reached (and nothing is recording in between)
This is usefull as the recorded messages are already corresponding to states between 2 actions have been chosen.
If permanent recording had been used instead, it would have been harder (while using the data) to pick up the states corresponding to moments between two actions.

## Absolute and Relative positions:
object.get_state(): gives absolute positions
utils.change_CS(): transforms into coordinates relative to baxter

TODO: perhaps add suffxes to position variables to make it clear
TODO: In order to generate a test set, try to make the robot move uniformly. And when it approaches the button, its delta should be small.
TODO: 1. add a fixed point for the robot
TODO: 2. add data augmentation, colors table and button, change each time!

"""
from __future__ import division, print_function

import argparse
import random
import subprocess
import time

import rospy
from std_msgs.msg import String
from tf import transformations

np = transformations.numpy
quat_conj = transformations.quaternion_conjugate
from geometry_msgs.msg import Point, Vector3, Vector3Stamped
from std_msgs.msg import Header
import baxter_interface
import arm_scenario_simulator as arm_sim
from arm_scenario_experiments import Recorder, utils, baxter_utils

# ['left_e0', 'left_e1', 'left_s0', 'left_s1', 'left_w0', 'left_w1', 'left_w2']
IK_SEED_POSITIONS = [-1.535, 1.491, -0.038, 0.194, 1.546, 1.497, -0.520]
Z_TABLE = 0.751
BUTTON_INIT_POS = [0.6, 0.30, 0.77]  # absolute
REF_POINT = [0.6, 0.30, 0.10]  # reference point present in every sequence
N_STEPS = 200
N_RECORDS = 20
CHANGE_BUTTON_POSITION = True  # Whether to change the button position at the start of each episode

delta = 0.05  # Apparently not used because action is randomly chosen
# Relative values
# Min max of what ?
mins = np.array([0.42, -0.1, -0.11])
maxs = np.array([0.75, 0.60, 0.35])

def main(path):
    # this is the expert controller.
    # Given the actual position of the end effector (ee),
    # it gives the optimal action to perform to get closer to the button
    def action_to_goal(end_point_position, button_pos_relative, delta=None):
        # TODO: use parameter to control output
        if delta is None:
            print("Random delta for updating position")
            delta = np.random.uniform(0.03, 0.07)

        button_pos_relative = np.array(button_pos_relative)
        end_point_position = np.array(end_point_position)
        action = np.sign(button_pos_relative - end_point_position) * delta

        print("action: {} \t delta:{}".format(action, delta))
        return action

    # TODO: fix the button to the table
    def resetButton(button_pos_absolute):
        """
        Reset the button position if it has moved
        :param button_pos_absolute: [float]
        """
        if np.linalg.norm(button_pos_absolute - utils.point2array(button.get_state().pose.position)) > 0.0005:
            button.set_state(position=Point(*button_pos_absolute), orientation=button_orientation)

    # Function that randomly put the button on the table (useful to initialize a new sequence)
    def moveButton(random_position=False):
        position = BUTTON_INIT_POS
        if random_position:
            position = np.random.uniform(mins, maxs)
            position[2] = BUTTON_INIT_POS[2]

        button.set_state(position=Point(*position))
        button_pos_from_topic = button.get_state().pose.position
        button_pos_absolute = utils.point2array(button_pos_from_topic)
        button_pos_relative = utils.change_CS(button_pos_absolute, baxter_position, baxter_orientation)
        button_pos_pub.publish(Point(*button_pos_relative))
        print("Changed button position: {} \t random={}".format(position, random_position))
        return button_pos_relative, button_pos_absolute

    def restoreLever():
        # sometimes the lever falls down. So try to replace it on the table
        def r(limit):
            """
            Draw for a random distribution in [-limit, limit]
            :param limit: (float)
            :return: (float)
            """
            return random.random() * 2 * limit - limit

        lever_position = utils.point2array(lever.get_state().pose.position)
        # This lever is no more on the table
        if abs(lever_position[2] - Z_TABLE) > 0.1:
            lever.set_state(Point(x=0.6 + r(0.1), y=0 + r(0.3), z=0.78))
            print("Lever restored on the table")

    # This sometimes causes an exception
    def move_limb_to_init():
        joints = None
        while not joints:
            position = REF_POINT
            try:
                joints = baxter_utils.IK(limb, position, ee_orientation, IK_SEED_POSITIONS)
            except Exception as e:
                try:
                    joints = baxter_utils.IK(limb, position, ee_orientation, IK_SEED_POSITIONS)
                except Exception as e:
                    raise
        limb.move_to_joint_positions(joints)
        return position

    # TODO right hand not hangling out of sight DONE
    def move_limb_right_to_init():
        joints = None
        # print(utils.point2array(limb_right.endpoint_pose()['position']))
        # [ 0.26033143 -0.74212844  0.11364821] initial position
        # [short side of table, long side, height]
        # when increasing, [forward ,left, high]
        while not joints:
            position = np.array([0.70, -0.62, 0.10]) + [np.random.uniform(-0.05, 0.05), np.random.uniform(-0.10, 0.07), np.random.uniform(-0.08, 0.08)]
            try:
                joints = baxter_utils.IK(limb_right, position, ee_orientation_right, IK_SEED_POSITIONS)
            except rospy.service.ServiceException:
                print("Exception calling the IK moving right limb")

        limb_right.move_to_joint_positions(joints)
        return position

    def wait_for_messages(excepts=None):
        excepts = excepts if excepts is not None else []
        while not recorder.all_buffers_full(excepts=excepts):
            print('waiting for messages')
            rospy.sleep(0.01)

    # communication
    pub = rospy.Publisher('babbler', String, queue_size=10)
    loop_rate = rospy.Rate(10)

    limb = baxter_interface.Limb('left')
    limb_right = baxter_interface.Limb('right')
    ee_orientation = baxter_utils.get_ee_orientation(limb)
    ee_orientation_right = baxter_utils.get_ee_orientation(limb_right)

    # those are publishers specially made to be listenned by the recorder,
    # so that we can publish and thus record exactly what we want when we want
    action_pub = rospy.Publisher('/robot/limb/left/endpoint_action', Vector3Stamped, queue_size=1)
    button_pos_pub = rospy.Publisher('/button1/position', Point, queue_size=1)

    # here we define what topics the recorder will listen to
    # (which is necessary to be able to record some message from them)
    recorder = Recorder(path, prefix='/recorded', topics=['/cameras/head_camera_2/image/compressed',
                                                          '/robot/joint_states',
                                                          '/robot/limb/left/endpoint_state',
                                                          '/robot/limb/left/endpoint_action',
                                                          '/button1/is_pressed',
                                                          '/button1/position'])
    lever = arm_sim.Lever('lever1')
    button = arm_sim.Button('button1')
    button_orientation = button.get_state().pose.orientation
    baxter = arm_sim.Button('baxter')
    baxter_pose = baxter.get_state().pose
    baxter_position = utils.point2array(baxter_pose.position)
    baxter_orientation = utils.quat2array(baxter_pose.orientation)

    # Actually starts the babbling
    for idx_record in range(N_RECORDS):
        print("\n Starting recording number {}".format(idx_record))
        rospy.sleep(1)
        print("Initializing robot...")
        # Init robot pose
        subprocess.call(["rosrun", "arm_scenario_experiments", "button_init_pose"])
        print("Init Robot pose over")

        recorder.new_bag('record_{}'.format(idx_record))
        # Change the button position if needed
        button_pos_relative, button_pos_absolute = moveButton(CHANGE_BUTTON_POSITION)
        print("Button absolute position: {}".format(button_pos_absolute))
        end_point_position = move_limb_to_init()
        print("End move limb to init")
        # move left limb into field of view
        move_limb_right_to_init()
        print("End move right limb to init")
        restoreLever()
        resetButton(button_pos_absolute)
        print("Restored lever and resetted button position")
        exit_position_relative = None
        follow_another_trajectory = False
        attempt_button_relative = None

        n_trial, n_successful_moves = 0, 0
        count_exit = 0
        count_stupid = 0
        is_stupid = False
        is_normal = False
        p_wrong_button = 0.85
        buffer_action = []
        while n_successful_moves < N_STEPS and n_trial < N_STEPS * 1.2:
            print("\nIteration {}/{}".format(n_trial + 1, N_STEPS))

            delta = np.random.uniform(0.03, 0.07)
            possible_deltas = [i * delta for i in range(-1, 2)]
            # communication
            n_trial += 1
            actual_mins = np.array(mins)
            if np.linalg.norm(button_pos_relative[0:2] - utils.point2array(limb.endpoint_pose()['position'])[0:2]) <= delta:
                actual_mins[2] -= delta
            if is_stupid:
                actual_mins[2] -= 0.07  # so it can touch the table surface

            if button.is_pressed():
                min_max_choice = [mins, maxs]

                exit_position_relative = np.random.uniform(mins, maxs)
                rand_id = np.random.randint(2)
                rand_min_or_max = np.random.randint(2)

                # change this so that the arm moves to more positions
                exit_position_relative[rand_id] = min_max_choice[rand_min_or_max][rand_id]
                print("Button is pressed. exit_pos: {}".format(exit_position_relative))

                # lifting up the arm while moving randomly
                for _ in range(3):
                    buffer_action.append([delta, np.random.choice([delta, -delta]), delta])
                follow_another_trajectory = True
                is_stupid = False
                is_normal = False

            elif not buffer_action:
                follow_no_button = np.random.uniform(0, 1) > p_wrong_button

                if follow_another_trajectory:
                    print("Restarting: following another trajectory")
                    # During some steps, try to reach somewhere
                    # else on table, to simulate a kind of "goal babbling"
                    buffer_action.append(action_to_goal(end_point_position, exit_position_relative))
                    count_exit += 1

                    if end_point_position[rand_id] <= mins[rand_id]\
                        or end_point_position[rand_id] >= maxs[rand_id]\
                        or count_exit > 20:
                        follow_another_trajectory = False
                        count_exit = 0

                elif is_stupid:
                    print("Following the wrong button")
                    buffer_action.append(action_to_goal(end_point_position, attempt_button_relative))
                    count_stupid += 1
                    if np.linalg.norm(end_point_position - attempt_button_relative) < delta or count_stupid > 5:
                        count_stupid = 0
                        is_stupid = False
                        print("Wrong button terminated")
                        buffer_action.append(np.concatenate((np.random.choice(possible_deltas, 2), [- delta])))
                        for _ in range(2):
                            buffer_action.append(np.concatenate((np.random.choice(possible_deltas, 2), [delta])))

                elif follow_no_button and not is_normal:
                    print("Start following the wrong button")
                    attempt_button_relative = [np.random.uniform(mins[0], maxs[0]), np.random.uniform(mins[1], maxs[1]),
                                               -0.17]  # try to touch the table surface

                    print("Target: {}".format(attempt_button_relative))
                    buffer_action.append(action_to_goal(end_point_position, attempt_button_relative))
                    is_stupid = True

                else:
                    buffer_action.append(action_to_goal(end_point_position, button_pos_relative))
                    is_normal = True
                    print("Acting normaly: going toward the button")

            action = buffer_action.pop(0)
            # TODO change this to make the robot arm move to more positions
            end_point_position = np.array(end_point_position)
            action = np.array(action)
            end_point_position_candidate = (end_point_position + action).clip(actual_mins, maxs)
            action = end_point_position_candidate - end_point_position

            try:
                joints = baxter_utils.IK(limb, end_point_position_candidate, ee_orientation)
            except:
                print("[ERROR] no joints position returned by the Inverse Kinematic fn")
                print("end_point_position_candidate:{}".format(end_point_position_candidate))

            if joints:
                action_pub.publish(Vector3Stamped(Header(stamp=rospy.Time.now()), Vector3(*action)))
                end_point_position = end_point_position_candidate
                n_successful_moves += 1
                wait_for_messages(excepts=['/button1/position'])
                recorder.dump_all()
                limb.move_to_joint_positions(joints, timeout=3)

        wait_for_messages(excepts=['/button1/position', '/robot/limb/left/endpoint_action'])
        recorder.dump_all()
        recorder.close_bag()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('path', type=str, help="path to bag file in which data will be recorded")
    args = parser.parse_args(rospy.myargv()[1:])

    print("Initializing babbler node... ")
    rospy.init_node("learning_to_press_node")
    print("Getting robot state... ")
    rs = baxter_interface.RobotEnable(baxter_interface.CHECK_VERSION)
    if rs.state().enabled:
        print("Robot already enabled")
    else:
        print("Enabling robot... ")
        rs.enable()
    print("Running. Ctrl-c to quit")
    try:
        main(args.path)
    except rospy.ROSInterruptException:
        pass

    subprocess.call(["rosrun", "arm_scenario_experiments", "button_bag_to_disk", "here"])
