#!/usr/bin/env python
""" This script controls baxter by randomly choosing position for the left-limb end effector and using the Inverse Kinematic service (hence IK) to reach this point.

The script also controls what is recorded, so that a snapshot of the world is recorded after every 3D position of the end-effector is reached (and nothing is recording in between)
This is usefull as the recorded messages are already corresponding to states between 2 actions have been chosen.
If permanent recording had been used instead, it would have been harder (while using the data) to pick up the states corresponding to moments between two actions.

## Absolute and Relative positions:
object.get_state(): gives absolute positions
utils.change_CS(): transforms into coordinates relative to baxter

TODO: perhaps add suffxes to position variables to make it clear
TODO: In order to generate a test set, try to make the robot move uniformly. And when it approaches the button, its delta should be small.
TODO: 1. add a fixed point for the robot
TODO: 2. add data augmentation, colors table and button, change each time!

"""
from __future__ import division, print_function

import argparse
import random
import subprocess
import time

import rospy
from std_msgs.msg import String
from tf import transformations

np = transformations.numpy
quat_conj = transformations.quaternion_conjugate
from geometry_msgs.msg import Point, Vector3, Vector3Stamped, Quaternion
from std_msgs.msg import Header
import baxter_interface
import arm_scenario_simulator as arm_sim
from arm_scenario_experiments import Recorder, utils, baxter_utils

# ['left_e0', 'left_e1', 'left_s0', 'left_s1', 'left_w0', 'left_w1', 'left_w2']
IK_SEED_POSITIONS = [-1.535, 1.491, -0.038, 0.194, 1.546, 1.497, -0.520]
Z_TABLE = 0.751
BUTTON_INIT_POS = [0.6, 0.30, 0.8]  # absolute
REF_POINT = [0.6, 0.30, 0.10]  # reference point present in every sequence
N_STEPS = 250
N_RECORDS = 75
CHANGE_BUTTON_POSITION = True  # Whether to change the button position at the start of each episode
RIGHT_ARM_STATIC = True # Whether to change the right arm position at the beginning of each sequence

DELTA_POS = 0.05
# Relative values
# Min max of what ?
mins = np.array([0.42, -0.1, -0.11])
maxs = np.array([0.75, 0.60, 0.35])

rand = np.random.uniform  # Alias

################# PARAMETERS OF THE DATA RECORDER: ################
change_table_color_per_sequence =  False
change_button_position_per_sequence = True
use_hardcoded_trajectory = False
# IMPORTANT: Set N of records and frames per record in MAIN PROGRAM AT THE END.
####################################################################


def main(path):
    # this is the expert controller.
    # Given the actual position of the end effector (ee),
    # it gives the optimal action to perform to get closer to the button
    def action_to_goal(end_point_position, button_pos_relative, delta=None):
        # TODO: use parameter to control output
        if delta is None:
            delta = DELTA_POS
            # print("Random delta for updating position")
            # delta = rand(0.03, 0.07)

        button_pos_relative = np.array(button_pos_relative)
        end_point_position = np.array(end_point_position)
        action = np.sign(button_pos_relative - end_point_position) * delta

        print("action: {} \t delta:{}".format(action, delta))
        return action

    def resetButton(button_pos_absolute):
        """
        Reset the button position if it has moved
        :param button_pos_absolute: [float]
        """
        if np.linalg.norm(button_pos_absolute - utils.point2array(button.get_state().pose.position)) > 0.0005:
            button.set_state(position=Point(*button_pos_absolute), orientation=button_orientation)

    def isOnTheTable(absolute_pos, threshold=0.1):
        pos = utils.point2array(absolute_pos)
        return abs(pos[2] - Z_TABLE) < threshold

    def overlappingBoundingBox(object1, obj1_new_pos, objects):
        objects = [object1] + objects
        positions = [o.get_state().pose.position for o in objects]
        boxes = [rospy.wait_for_message('/mesh_bounding_box/{}'.format(o.gazebo_name), Vector3, 1) for o in objects]

        box1 = boxes[0]
        x1, y1 = obj1_new_pos[0] - box1.x / 2, obj1_new_pos[1] - box1.y / 2

        for i in range(len(objects)):
            if i == 0:
                continue
            x2, y2 = positions[i].x - boxes[i].x / 2, positions[i].y - boxes[i].y / 2
            is_overlapping = not (x1 + box1.x < x2 or x2 + boxes[i].x < x1 or y1 + box1.y < y2 or y2 + boxes[i].y < y1)
            if is_overlapping:
                return True

        return False

    # Function that randomly put the button on the table (useful to initialize a new sequence)
    def moveButton(random_position=False):
        position = BUTTON_INIT_POS
        if random_position:
            position = rand(mins, maxs)
            position[2] = BUTTON_INIT_POS[2]

            while overlappingBoundingBox(button, position, [lever]):
                print("Button and lever are overlapping, retrying a new position...")
                position = rand(mins, maxs)
                position[2] = BUTTON_INIT_POS[2]

        button.set_state(position=Point(*position), orientation=Quaternion(0, 0, 0, 0))
        button_pos_from_topic = button.get_state().pose.position
        button_pos_absolute = utils.point2array(button_pos_from_topic)
        button_pos_relative = utils.change_CS(button_pos_absolute, baxter_position, baxter_orientation)
        button_pos_pub.publish(Point(*button_pos_relative))
        print("Changed button position: {} \t random={}".format(position, random_position))
        return button_pos_relative, button_pos_absolute

    def restoreLever():
        # sometimes the lever falls down. So try to replace it on the table
        def r(limit):
            """
            Draw for a random distribution in [-limit, limit]
            :param limit: (float)
            :return: (float)
            """
            return random.random() * 2 * limit - limit

        # This lever is no more on the table
        if not isOnTheTable(lever.get_state().pose.position):
            lever.set_state(Point(x=0.6 + r(0.1), y=0 + r(0.3), z=0.78))
            print("Lever restored on the table")

    # This sometimes causes an exception
    def move_limb_to_init():
        joints = None
        while not joints:
            position = REF_POINT
            try:
                joints = baxter_utils.IK(limb, position, ee_orientation, IK_SEED_POSITIONS)
            except Exception as e:
                try:
                    joints = baxter_utils.IK(limb, position, ee_orientation, IK_SEED_POSITIONS)
                except Exception as e:
                    raise
        limb.move_to_joint_positions(joints)
        return position

    # TODO right hand not hangling out of sight DONE
    def move_limb_right_to_init():
        joints = None
        # print(utils.point2array(limb_right.endpoint_pose()['position']))
        # [ 0.26033143 -0.74212844  0.11364821] initial position
        # [short side of table, long side, height]
        # when increasing, [forward ,left, high]
        while not joints:
            position = np.array([0.70, -0.62, 0.10]) + [rand(-0.05, 0.05), rand(-0.10, 0.07), rand(-0.08, 0.08)]
            try:
                joints = baxter_utils.IK(limb_right, position, ee_orientation_right, IK_SEED_POSITIONS)
            except rospy.service.ServiceException:
                print("Exception calling the IK moving right limb")

        limb_right.move_to_joint_positions(joints)
        return position

    def wait_for_messages(excepts=None):
        excepts = excepts if excepts is not None else []
        while not recorder.all_buffers_full(excepts=excepts):
            print('waiting for messages')
            rospy.sleep(0.01)


    limb = baxter_interface.Limb('left')
    limb_right = baxter_interface.Limb('right')
    ee_orientation = baxter_utils.get_ee_orientation(limb)
    ee_orientation_right = baxter_utils.get_ee_orientation(limb_right)

    # those are publishers specially made to be listenned by the recorder,
    # so that we can publish and thus record exactly what we want when we want
    action_pub = rospy.Publisher('/robot/limb/left/endpoint_action', Vector3Stamped, queue_size=1)
    button_pos_pub = rospy.Publisher('/button1/position', Point, queue_size=1)

    # here we define what topics the recorder will listen to
    # (which is necessary to be able to record some message from them)
    recorder = Recorder(path, prefix='/recorded', topics=['/cameras/head_camera_2/image/compressed',
                                                          '/robot/joint_states',
                                                          '/robot/limb/left/endpoint_state',
                                                          '/robot/limb/left/endpoint_action',
                                                          '/button1/is_pressed',
                                                          '/button1/position'])
    lever = arm_sim.Lever('lever1')
    button = arm_sim.Button('button1')
    button_orientation = button.get_state().pose.orientation
    baxter = arm_sim.Button('baxter')
    baxter_pose = baxter.get_state().pose
    baxter_position = utils.point2array(baxter_pose.position)
    baxter_orientation = utils.quat2array(baxter_pose.orientation)

    # Actually starts the babbling
    for idx_record in range(N_RECORDS):
        start_time = time.time()
        print("\n Starting recording number {}".format(idx_record))
        rospy.sleep(1)
        print("Initializing robot...")
        # Init robot pose
        subprocess.call(["rosrun", "arm_scenario_experiments", "button_init_pose"])
        print("Init Robot pose over")

        recorder.new_bag('record_{:03d}'.format(idx_record))
        # Change the button position if needed
        button_pos_relative, button_pos_absolute = moveButton(CHANGE_BUTTON_POSITION)
        rospy.sleep(1)
        while not isOnTheTable(button.get_state().pose.position, threshold=0.01):
            print("Button not on the table, retrying init")
            button_pos_relative, button_pos_absolute = moveButton(CHANGE_BUTTON_POSITION)
            rospy.sleep(2)
        # resetButton(button_pos_absolute)
        print("Button absolute position: {}".format(button_pos_absolute))

        end_point_position = move_limb_to_init()
        print("End move limb to init")
        if not RIGHT_ARM_STATIC:
            # move left limb into field of view
            move_limb_right_to_init()
            print("End move right limb to init")
        restoreLever()
        print("Restored lever position")
        exit_position_relative = None
        follow_another_trajectory = False
        attempt_button_relative = None

        n_trial, n_successful_moves = 0, 0
        count_exit = 0
        count_stupid = 0
        is_stupid = False
        is_normal = False
        p_wrong_button = 0.85
        buffer_action = []
        while n_successful_moves < N_STEPS and n_trial < N_STEPS * 1.2:
            print("\nRecord {} - Iteration {}/{}".format(idx_record, n_trial + 1, N_STEPS))

            # delta = rand(0.03, 0.07)
            possible_deltas = [i * DELTA_POS for i in range(-1, 2)]
            # communication
            n_trial += 1
            actual_mins = np.array(mins)
            if np.linalg.norm(button_pos_relative[0:2] - utils.point2array(limb.endpoint_pose()['position'])[0:2]) <= DELTA_POS:
                actual_mins[2] -= DELTA_POS
            if is_stupid:
                actual_mins[2] -= 0.07  # so it can touch the table surface

            if button.is_pressed():
                min_max_choice = [mins, maxs]

                exit_position_relative = rand(mins, maxs)
                rand_id = np.random.randint(2)
                rand_min_or_max = np.random.randint(2)

                # change this so that the arm moves to more positions
                exit_position_relative[rand_id] = min_max_choice[rand_min_or_max][rand_id]
                print("Button is pressed. exit_pos: {}".format(exit_position_relative))

                # lifting up the arm while moving randomly
                for _ in range(3):
                    buffer_action.append([DELTA_POS, np.random.choice([DELTA_POS, -DELTA_POS]), DELTA_POS])
                follow_another_trajectory = True
                is_stupid = False
                is_normal = False

            elif not buffer_action:
                follow_no_button = rand(0, 1) > p_wrong_button

                if follow_another_trajectory:
                    print("Restarting: following another trajectory")
                    # During some steps, try to reach somewhere
                    # else on table, to simulate a kind of "goal babbling"
                    buffer_action.append(action_to_goal(end_point_position, exit_position_relative))
                    count_exit += 1

                    if end_point_position[rand_id] <= mins[rand_id] \
                            or end_point_position[rand_id] >= maxs[rand_id] \
                            or count_exit > 20:
                        follow_another_trajectory = False
                        count_exit = 0

                elif is_stupid:
                    print("Following the wrong button")
                    buffer_action.append(action_to_goal(end_point_position, attempt_button_relative))
                    count_stupid += 1
                    if np.linalg.norm(end_point_position - attempt_button_relative) < DELTA_POS or count_stupid > 5:
                        count_stupid = 0
                        is_stupid = False
                        print("End of following the wrong button")
                        buffer_action.append(np.concatenate((np.random.choice(possible_deltas, 2), [- DELTA_POS])))
                        for _ in range(2):
                            buffer_action.append(np.concatenate((np.random.choice(possible_deltas, 2), [DELTA_POS])))

                elif follow_no_button and not is_normal:
                    print("Start following the wrong button")
                    # try to touch the table surface
                    attempt_button_relative = [rand(mins[0], maxs[0]), rand(mins[1], maxs[1]), -0.17]

                    print("Target: {}".format(attempt_button_relative))
                    buffer_action.append(action_to_goal(end_point_position, attempt_button_relative))
                    is_stupid = True

                else:
                    buffer_action.append(action_to_goal(end_point_position, button_pos_relative))
                    is_normal = True
                    print("Acting normaly: going toward the button")

            action = buffer_action.pop(0)
            # TODO change this to make the robot arm move to more positions
            end_point_position = np.array(end_point_position)
            action = np.array(action)
            end_point_position_candidate = (end_point_position + action).clip(actual_mins, maxs)
            action = end_point_position_candidate - end_point_position

            try:
                joints = baxter_utils.IK(limb, end_point_position_candidate, ee_orientation)
            except:
                print("[ERROR] no joints position returned by the Inverse Kinematic fn")
                print("end_point_position_candidate:{}".format(end_point_position_candidate))

            if joints:
                action_pub.publish(Vector3Stamped(Header(stamp=rospy.Time.now()), Vector3(*action)))
                end_point_position = end_point_position_candidate
                n_successful_moves += 1
                wait_for_messages(excepts=['/button1/position'])
                recorder.dump_all()
                limb.move_to_joint_positions(joints, timeout=3)

        wait_for_messages(excepts=['/button1/position', '/robot/limb/left/endpoint_action'])
        recorder.dump_all()
        recorder.close_bag()
        print("Record {} took {:.2f}s".format(idx_record, time.time() - start_time))


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('path', type=str, help="path to bag file in which data will be recorded")
    args = parser.parse_args(rospy.myargv()[1:])

    print("Initializing babbler node... ")
    rospy.init_node("learning_to_press_node")
    print("Getting robot state... ")
    rs = baxter_interface.RobotEnable(baxter_interface.CHECK_VERSION)
    if rs.state().enabled:
        print("Robot already enabled")
    else:
        print("Enabling robot... ")
        rs.enable()
    print("Running. Ctrl-c to quit")
    try:
        main(args.path)
    except rospy.ROSInterruptException:
        pass

    subprocess.call(["rosrun", "arm_scenario_experiments", "button_bag_to_disk", "here"])
    # TODO This should be called instead to transform .bag files into records of images and text
    #rosrun arm_scenario_experiments extract_bags
