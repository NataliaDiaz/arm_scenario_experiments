#!/usr/bin/env python

import math
from copy import copy
import random
import argparse

import rospy
from tf import transformations as tft
np = tft.numpy
quat_mul = tft.quaternion_multiply
quat_conj = tft.quaternion_conjugate

from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion, Vector3, Vector3Stamped
from std_msgs.msg import Header, String, Empty
from sensor_msgs.msg import JointState

from baxter_core_msgs.srv import SolvePositionIK, SolvePositionIKRequest
import baxter_interface
from ann4smc import Recorder
import arm_scenario_simulator as arm_sim


def main(path):

    action_pub = rospy.Publisher('/robot/limb/left/endpoint_action', Vector3Stamped, queue_size=1)
    button_pos_pub = rospy.Publisher('/button1/postion', Point, queue_size=1)

    limb = baxter_interface.Limb('left')
    o = limb.endpoint_pose()['orientation']
    orientation = Quaternion(w=o.w, x=o.x, y=o.y, z=o.z)
    recorder = Recorder(path, prefix='', topics = [ '/cameras/head_camera_2/image/compressed', 
                                                    '/robot/joint_states',
                                                    '/robot/limb/left/endpoint_state',  
                                                    '/robot/limb/left/endpoint_action', 
                                                    '/button1/is_pressed', 
                                                    '/button1/position'])
    recorder.new_bag('record')
    recorder.dump_all()

    
    delta = 0.05
    possible_deltas = [i*delta for i in xrange(-1,2)]
    mins = np.array([0.30,  -0.10, -0.15])
    maxs = mins + delta*np.array([12, 20, 13])
    p0 = mins + delta*np.array([6, 10, 6])

    button = arm_sim.Button('button1')
    baxter = arm_sim.Button('baxter')
    baxter_pose = baxter.get_state().pose
    button_pos = point2array( button.get_state().pose.position )
    button_pos_relative = change_CS( button_pos, point2array(baxter_pose.position), quat2array(baxter_pose.orientation))
    button_pos_pub.publish( Point(*button_pos_relative) )
    print('button pose : ', button_pos)
    print('baxter position : ', point2array(baxter_pose.position))
    print('baxter orientation : ', quat2array(baxter_pose.orientation))
    print('button pose relative : ', button_pos_relative)

    def action_to_goal(end_point_position, button_pos_relative):
        return np.sign(button_pos_relative-end_point_position)*delta

    end_point_position  = p0 
    k, k_success = 0, 0
    buffer_action = []
    nexpert, nrandom = 10, 20
    recently_pressed = False
    expert_control = False
    while k_success<5000 and k<10000:
        k +=1 

        if button.is_pressed():
            buffer_action = [np.concatenate((np.random.choice(possible_deltas,2),[delta])) for _ in xrange(6)]
            recently_pressed = True
            expert_control = False
        elif not buffer_action:
            if nrandom<k%(nexpert+nrandom): 
                expert_control = not recently_pressed
            else: 
                recently_pressed = False
                expert_control = False

            if expert_control:
                buffer_action.append( action_to_goal(end_point_position, button_pos_relative) )
            else:
                buffer_action.append( np.random.choice(possible_deltas,3) )
        
        print('is_pressed', button.is_pressed())
        print('expert_control', expert_control)
        action = buffer_action.pop(0)
        print('action', action)
        end_point_position_candidate = (end_point_position+action).clip(mins, maxs)
        action = end_point_position_candidate - end_point_position
        joints = IK(limb, Point(*end_point_position_candidate), orientation)
        if joints:
            end_point_position = end_point_position_candidate
            k_success +=1
            action_pub.publish( Vector3Stamped(Header(stamp=rospy.Time.now(),frame_id='base'), Vector3(*action) ) )
            limb.move_to_joint_positions(joints, timeout = 3)
            recorder.dump_all()

    recorder.close_bag()
      
def point2array(point):
    return np.array([point.x, point.y, point.z])
def quat2array(quat):
    return np.array([quat.x, quat.y, quat.z, quat.w])

def change_CS(point, translation, quaternion):
    ''' Get the coordinates of a point in frame B from its coordinates in frmae A.
        The translation must be the coordinates expressed in frame A of the origin of frame B
        The rotation must be the active rotation that takes the points (A,B,C) of coordinates {(1,0,0) (0,1,0) (0,0,1)} in frame A to the points (A',B',C') of coordinates {(1,0,0) (0,1,0) (0,0,1)} in frame B, when the two frames are superimposed (no translation)'''
    return quat_rotate((point-translation), quat_conj(quaternion))
    

def quat_rotate(point, quaternion):
    p = np.concatenate((point, [0]))
    res_inter = quat_mul(quaternion,p)
    return quat_mul(res_inter, quat_conj(quaternion))[0:3]


def IK(limb, position, orientation,verbose = 0):
    ns = "ExternalTools/" + limb.name + "/PositionKinematicsNode/IKService"
    iksvc = rospy.ServiceProxy(ns, SolvePositionIK)
    ikreq = SolvePositionIKRequest()
    pose = PoseStamped(
            header=Header(stamp=rospy.Time.now(), frame_id='base'),
            pose=Pose(position,orientation)
        )
    names = ['left_e0', 'left_e1', 'left_s0', 'left_s1', 'left_w0', 'left_w1', 'left_w2']
    positions = [-1.5352305689404009, 1.4906375729922043, -0.038481535830354296, 0.1940629459492209, 1.5458392657611721, 1.4966324394341486, -0.5197399373727922]
    velocities, efforts = [0]*7, [0]*7
    seed = JointState(Header(stamp=rospy.Time.now(), frame_id='base'), names, positions, velocities, efforts)

    ikreq.pose_stamp.append(pose)
    ikreq.seed_angles.append(seed)
    try:
        rospy.wait_for_service(ns, 5.0)
        resp = iksvc(ikreq)
    except (rospy.ServiceException, rospy.ROSException), e:
        rospy.logerr("Service call failed: %s" % (e,))
        raise Exception

    if (resp.isValid[0]):
        # Format solution into Limb API-compatible dictionary
        limb_joints = dict(zip(resp.joints[0].name, resp.joints[0].position))
        if verbose>0:
            print("SUCCESS - Valid Joint Solution Found :")
            print "\nIK Joint Solution:\n", limb_joints
            print "------------------"
            print "Response Message:\n", resp
        return limb_joints

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('path', type=str, help="path to bag file")
    args = parser.parse_args(rospy.myargv()[1:])

    print("Initializing babbler node... ")
    rospy.init_node("node_clement")
    print("Getting robot state... ")
    rs = baxter_interface.RobotEnable(baxter_interface.CHECK_VERSION)
    print("Enabling robot... ")
    rs.enable()
    print("Running. Ctrl-c to quit")
    try: main(args.path)
    except rospy.ROSInterruptException:  pass
